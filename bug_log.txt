Checkpoint 1 bugs:

Bug #1:
    Problem: We were still boot - looping as we were working on loading the idt
    What was the issue: We realized we weren't calling lidt
    What we did: we called lidt(idt_desc_ptr) after the handlers in the idt

Bug #2:
    Problem: The keyboard interrupt is detected but we couldn't press a key repeatedly
    What was the issue: Our send_eoi was wrong - we saw on piazza that our send_eoi needed to be correct for it to be able to do it
    What we did: we forgot to -=8 the irq number for if the IRQ is a slave

Bug #3:
    Problem: The keyboard interrupt is detected but when we try to press a key repeatedly, it does not print every time we press/unpress. 
    What was the issue: In the handler, we forgot to read from the keyboard data port so it wasn't sending the next interrupt. 
    What we did: we added inb(0x60) in the keyboard handler.

Bug #4:
    Problem: out paging wasn't working
    What was the issue: we weren't loading the proper values into cr3
    What we did: We read the intel ISA manual and found out that we need to AND cr3 with 0x0000fff to clear the base address but preserve the other bits
        and then OR that with the parameter

Bug #5:
    Problem: Our paging wasn't working 
    What was the issue: We did the wrong offset because we were overthinking the entire thing with initializing paging
    What we did: we changed the offset for page_directory[1] to 0x40000 | 0x193

Bug #6:
    Problem: When we commented out the cli/sti in the keyboard handler, the keyboard wasn't working
    What was the issue: we weren't returning from the interrupt handler properly
    What we did: we created an assembly linkage so that we can iret instead of just the normal ret

Bug #7:
    Problem: our paging wasn't working properly because it wouldn't print out the "Enabling Interrupts" after initializing paging
    What was the issue: we were bit shifting the VIDEO (page 0xB8000) by 12 when we didn't need to
    What we did: we got rid of the bit shift 12 and it worked

Checkpoint 2 bugs:

Bug #1:
    Problem: verylargetextwithverylongname.txt doesn't print out properly for dir_read
    What was the issue:  the new line character was in the the buffer
    What we did: fixed it so the new line is printed after the whole buffer is printed

Bug #2:
    Problem: file_inode.length was returning 0 so the file wasn't being read properly
    What was the issue: the filesys_start was an int
    What we did: changed so the filesys_start was a char (int8_t)

Bug #3:
    Problem: No characters were being printed on screen when making terminal_read
    What was the issue: System call calls cli() automatically
    What we did: add an sti() after our initializing in our kernel to unmask the interrupt

Bug #4:
    Problem: New line was being printed after every terminal read call instead of at the very end of buffer
    What was the issue: NEWLINE_FLAG was set to 0 after every call on terminal_read
    What we did: Only set NEWLINE_FLAG if we reached the end of the buffer rather than after each call

Bug #5:
    Problem: Experiencing segmentation fault from terminal_read after 1 successful iteration
    What was the issue: We were trying to access values in keyboard_buffer not initialized 
    What we did: Reset buf_idx to 0 after clearing the buffer to reset the index for the next terminal read

Bug #6:
    Problem: Caps lock was not turning off
    What was the issue: We were never actually setting our caps lock flag back to 0
    What we did: set a XOR with the flag when checking if the specific key was pressed to turn off/on